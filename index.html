<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<link rel="icon" href="favicon.ico" type="image/x-icon">
<title>Ocean's Echo</title>
<script type="module">
import zim from "https://zimjs.org/cdn/015/zim_three";
new Frame(FIT, 1024, 768, black, black, ready);
function ready() {
    
const three = new Three({
        width:window.innerWidth, 
        height:window.innerHeight, 
        cameraPosition:new THREE.Vector3(0,0,100),
        ortho:true,
        textureActive:true
    });
if (three.success) {
    const scene = three.scene;
    const camera = three.camera;
    const renderer = three.renderer;
//SKYBOX
    const skyTexture = new THREE.TextureLoader().load("assets/ocean-1.jpeg"); //maybe 3, 4 is too busy
    const skyBoxGeometry = new THREE.SphereGeometry(100000, 32, 32);
    const skyBoxMaterial = new THREE.MeshBasicMaterial({map:skyTexture, side:THREE.BackSide});
    const skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
    scene.add(skyBox);
// CONTROLS
    const controls = new OrbitControls(camera, three.canvas);
// FISH
    const loader = new GLTFLoader();

// Function to update the fish's direction and speed
function updateFishMovement(fish, targetDirection, speed) {
    // Randomly change direction and speed
    targetDirection.x += 0.1 * (0.5 - Math.random());
    targetDirection.y += 0.1 * (0.5 - Math.random());
    targetDirection.z += 0.1 * (0.5 - Math.random());
    targetDirection.normalize(); // Keep the direction vector normalized
    speed.value = 0.5 + Math.random() * 2; // Change speed to a value between 0.5 and 2.5

    // Keep the fish within bounds
    const bounds = 50;
    if (fish.position.x > bounds || fish.position.x < -bounds) {
        targetDirection.x = -targetDirection.x;
    }
    if (fish.position.y > bounds || fish.position.y < -bounds) {
        targetDirection.y = -targetDirection.y;
    }
    if (fish.position.z > bounds || fish.position.z < -bounds) {
        targetDirection.z = -targetDirection.z;
    }
}

// Main animation loop
function animateFish(fish) {
    let targetDirection = new THREE.Vector3(-0.5 + Math.random(), -0.5 + Math.random(), -0.5 + Math.random());
    let speed = { value: 1 };

    function animate() {
        requestAnimationFrame(animate);

        // Move the fish
        fish.position.add(targetDirection.clone().multiplyScalar(speed.value));

        // Periodically update movement direction and speed
        if (Math.random() < 0.05) { // Adjust this value to change how often the fish changes direction
            updateFishMovement(fish, targetDirection, speed);
        }

        // Render the scene
        renderer.render(scene, camera);
    }

    animate();
}

const underwaterAmbience = new Audio('assets/underwater.mp3');
const underwaterMusic = new Audio('assets/underwater-music.mp3');
// underwaterAmbience.loop = true;
// underwaterMusic.loop = true;
// new Button(100, 50, "Play", white, red, 20, 10, 10, 10, 10, 10, function() {
//     underwaterAmbience.play();
//     underwaterMusic.play();
// })
// // .center().mov(0, 100).show();

// new Button(100, 50, "Pause", white, red, 20, 10, 10, 10, 10, 10, function() {
//     underwaterAmbience.pause();
//     underwaterMusic.pause();
// })
// // .center().mov(0, 200).show();


// After loading the fish
loader.load('assets/man-o-war.glb', function(gltf) {
    
    const fish1 = gltf.scene;
    const fish2 = gltf.scene.clone();
    const fish3 = gltf.scene.clone();
    fish1.scale.set(15, 15, 15);
    fish2.scale.set(15, 15, 15);
    fish2.position.set(0, 0, 50);
    scene.add(fish2);
    fish1.position.set(0, 0, -50);
    scene.add(fish1);

    // Call the animation function
    animateFish(fish1);
    animateFish(fish2);
}, undefined, function(error) {
    console.error(error);
});


// LIGHTS
const light1 = new THREE.DirectionalLight(0xffffff, 2*Math.PI);
light1.position.set(0,250,100);
scene.add(light1);
const light2 = new THREE.DirectionalLight(0xffffff, 2*Math.PI);
light2.position.set(100,250,-100);
scene.add(light2);

// Texture Active
   // PANEL
   const panel = new TextureActive({
      width:W,
      height:H,
      color:white.toAlpha(.8),
      corner:20
   });
   const circle = new Circle(100,red).center(panel).drag();

   // BACK OF PANEL
const backing = new TextureActive({
width:panel.width,
height:panel.height,
color:black,
corner:20,
animated:false,
interactive:false
});
TextureActive.makeBacking(backing.width, backing.height).addTo(backing); // CANVAS WINDOW

   const three = new Three({
width:window.innerWidth,
height:window.innerHeight,
cameraPosition:new THREE.Vector3(0,0,500),
textureActive:true
});

const textureActives = new TextureActives([panel, backing], THREE, three, renderer, scene, camera, controls, 1, 0, 1500);

// can capture raydown, raymove, rayup, rayover and rayout
textureActives.on("raymove", e=>{
// zog(e.intersect.distance);
});

const canvasWindow = three.makePanel(panel, textureActives);
scene.add(canvasWindow);

// BACK OF PANEL
const canvasWindowBacking = three.makePanel(backing, textureActives, true, .5) // transparent and alpha
scene.add(canvasWindowBacking);
canvasWindowBacking.rotation.y = 180*RAD; // flip it around the other way

} else {
    // WEBGL NOT SUPPORTED
    const pane = new Pane(W+100, 200, "SORRY - NEEDS WEBGL", light);
    pane.show();
}


//End of ready
}
</script>
<meta name="viewport" content="width=device-width, user-scalable=no" />
</head>
<body>
<script>
    // traffic plus
    //  1x1 pixel image to track page views
    // var r=Math.round(Math.random()*1000000);
    // document.write('<img src=/cgi-bin/traffic_plus?company=danzen&page=zimTextureActivesHud&r='+r+' width=1 height=1>');
</script>
</body>
</html>